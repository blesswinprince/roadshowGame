<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">

  <title>CI/CD Defense Arcade</title>

  <style>
    html, body {
  height: 100%;
  overflow: hidden !important;
}
    :root{
      --bg:#040611;
      --bg-soft:#071327;
      --neon-cyan:#6ef6ff;
      --neon-green:#6effa0;
      --neon-orange:#ffb36b;
      --panel: rgba(255,255,255,0.05);
      --white-soft:#e8f7ff;
    }

    html,body{
      height:100%;
      margin:0;
      font-family:system-ui,-apple-system,BlinkMacSystemFont,"Segoe UI",Roboto,Helvetica,Arial,sans-serif;
      background:
        radial-gradient(1200px 500px at 10% 6%, rgba(110,246,255,0.08), transparent),
        radial-gradient(900px 500px at 80% 100%, rgba(255,179,107,0.08), transparent),
        linear-gradient(180deg,#02030a,var(--bg));
      color:var(--white-soft);
    }

    .wrap{
      padding:12px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:12px;
    }

    /* ---------- HEADER / TITLE ---------- */

    header{
      width:98%;
      max-width:1400px;
      display:flex;
      justify-content:space-between;
      align-items:center;
    }

    h1{
      margin:0;
      display:flex;
      flex-direction:column;
      font-weight:900;
      letter-spacing:0.08em;
      text-transform:uppercase;
    }

    .title-main{
      font-size:26px;
      color:#fefefe;
      text-shadow:0 2px 0 #18202f,
                  0 0 18px rgba(110,246,255,0.6);
    }

    .title-sub{
      font-size:14px;
      color:var(--neon-cyan);
      text-shadow:0 0 12px rgba(110,246,255,0.5);
    }

    .controls{
      display:flex;
      gap:10px;
      align-items:center;
    }

    /* Pills for player/score/combo */

    .pill{
      display:flex;
      flex-direction:column;
      padding:4px 10px;
      border-radius:999px;
      background:radial-gradient(circle at 0% 0%, rgba(255,255,255,0.14), transparent 50%),
                 linear-gradient(135deg, rgba(2,8,23,0.9), rgba(9,16,36,0.95));
      border:1px solid rgba(255,255,255,0.18);
      box-shadow:0 3px 8px rgba(0,0,0,0.5);
      min-width:72px;
    }

    .pill-label{
      font-size:10px;
      text-transform:uppercase;
      opacity:0.7;
    }

    .pill-value{
      font-size:14px;
      font-weight:800;
      margin-top:1px;
    }

    .pill-player .pill-value{
      color:var(--neon-cyan);
    }
    .pill-score .pill-value{
      color:var(--neon-orange);
    }
    .pill-combo .pill-value{
      color:var(--neon-green);
    }

    /* Buttons */

    button{
      background:linear-gradient(180deg, rgba(255,255,255,0.08), rgba(255,255,255,0.02));
      border:1px solid rgba(255,255,255,0.18);
      padding:8px 12px;
      border-radius:999px;
      color:#f7fcff;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
      display:inline-flex;
      align-items:center;
      gap:6px;
      box-shadow:0 4px 12px rgba(0,0,0,0.4);
    }
    button:hover{
      transform:translateY(-1px);
      box-shadow:0 7px 18px rgba(0,0,0,0.6);
    }
    button:active{
      transform:translateY(0);
      box-shadow:0 2px 6px rgba(0,0,0,0.6);
    }

    .btn-primary{
      background:linear-gradient(135deg,#4cffb7,#58c1ff);
      border-color:rgba(255,255,255,0.3);
      color:#041018;
    }

    .btn-secondary{
      background:linear-gradient(135deg,#19263c,#101829);
    }

    /* ---------- MAIN LAYOUT ---------- */

    .main{
      width:98%;
      max-width:1400px;
      display:flex;
      flex-direction:column;
      gap:12px;
    }

    /* HUD chips */

    .hud{
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
      padding:8px 10px;
      background:linear-gradient(135deg, rgba(9,16,36,0.9), rgba(5,15,27,0.95));
      border-radius:16px;
      border:1px solid rgba(110,246,255,0.18);
      box-shadow:0 10px 25px rgba(0,0,0,0.6);
      flex-wrap:wrap;
    }

    .hud-chip{
      display:flex;
      align-items:center;
      gap:5px;
      padding:4px 10px;
      border-radius:999px;
      background:rgba(3,15,30,0.9);
      border:1px solid rgba(255,255,255,0.06);
    }

    .hud-label{
      font-size:11px;
      text-transform:uppercase;
      opacity:0.75;
    }
    .hud-value{
      font-size:13px;
      font-weight:700;
    }
    .hud-unit{
      font-size:11px;
      opacity:0.75;
      margin-left:2px;
    }
    .hud-chip-timer{
      background:radial-gradient(circle at 0 0, rgba(255,255,255,0.12), transparent 55%),
                 linear-gradient(135deg,rgba(255,188,120,0.12),rgba(255,164,90,0.3));
    }

    /* ---------- GAME AREA ---------- */

@media (max-width: 600px) {
  .game-area {
    flex: none;
    overflow: hidden !important;   /* üî• BLOCK SCROLL */
    height: 520px !important;      /* stable fixed height */
    min-height: 520px !important;
    padding-bottom: 0;
  }
}

    .grid{
      position:absolute;
      inset:0;
      pointer-events:none;
      background-image:
        linear-gradient(rgba(110,246,255,0.03) 1px, transparent 1px),
        linear-gradient(90deg, rgba(110,246,255,0.02) 1px, transparent 1px);
      background-size:60px 60px;
      opacity:0.7;
    }

    @media (max-width: 600px) {
  .lanes {
    order: 1;
    height: 360px !important;     /* MORE room for bug path */
    min-height: 360px !important;
    width: 100%;
    flex-direction: row;
    margin: 20px 0 0 0;
    overflow: visible;             /* Gates won't get clipped */
  }

  .lane {
    min-width: 58px;
    border-radius: 10px;
    overflow: visible;
    position: relative;
  }
}

    .lane::before{
      content:"";
      position:absolute;
      inset:0;
      border-radius:inherit;
      border:1px solid transparent;
      transition:border-color 0.2s ease, box-shadow 0.2s ease;
    }

    .lane .line-left{
      position:absolute;
      left:10px;
      top:6px;
      bottom:6px;
      width:3px;
      border-radius:999px;
      background:linear-gradient(180deg, rgba(110,246,255,0.8), transparent);
    }

    .lane .lane-label{
      position:absolute;
      left:22px;
      top:6px;
      color:rgba(255,255,255,0.9);
      font-size:11px;
      font-weight:700;
      text-transform:uppercase;
    }

    .lane-hover::before{
      border-color:rgba(110,246,255,0.6);
      box-shadow:0 0 0 1px rgba(110,246,255,0.5);
    }

    /* PROD column ‚Äì tall vertical on desktop */

    @media (max-width: 600px) {
  .prod-column {
    order: 2;
    margin-top: 12px;
    position: relative;
    width: 240px;
    height: 80px;
    z-index: 50;               /* üî• BUG GOES BEHIND PROD */
  }
}
.bug {
  z-index: 20;  /* PROD above bug always */
}
    @media (max-width: 600px) {
  .bug span:nth-child(2) {
    display: none !important;  /* force hide text */
  }
}
    .prod-crack{
      position:absolute;
      inset:5px;
      border-radius:inherit;
      border:2px dashed rgba(255,200,120,0);
      pointer-events:none;
      box-shadow:none;
      transition:
        border-color 0.2s ease,
        box-shadow 0.2s ease,
        opacity 0.2s ease;
    }

    .prod-icon{
      font-size:30px;
      color:var(--neon-orange);
      text-shadow:0 0 18px rgba(255,140,60,0.5);
    }

    .prod-label{
      font-size:13px;
      font-weight:800;
      letter-spacing:0.09em;
      text-transform:uppercase;
      opacity:0.95;
    }

    .health{
      width:88px;
      height:14px;
      background:rgba(0,0,0,0.55);
      border-radius:999px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.2);
    }

    .health-inner{
      height:100%;
      background:linear-gradient(90deg,var(--neon-green),var(--neon-cyan));
      width:100%;
      transition:width 0.18s ease;
    }

    /* Bugs */

    .bug{
      position:absolute;
      display:flex;
      align-items:center;
      gap:6px;
      padding:6px 10px;
      border-radius:999px;
      background:linear-gradient(90deg, rgba(110,246,255,0.16), rgba(110,246,255,0.04));
      box-shadow:0 10px 30px rgba(0,0,0,0.6);
      color:#fff;
      font-weight:700;
      pointer-events:none;
      white-space:nowrap;
      font-size:12px;
    }

    .bug .icon{
      font-size:16px;
    }

    .spark{
      position:absolute;
      width:8px;
      height:8px;
      border-radius:50%;
      pointer-events:none;
      box-shadow:0 0 12px currentColor;
    }

    /* Gate bar */

    .gate-bar{
      display:flex;
      gap:18px;
      align-items:center;
      justify-content:center;
      padding:10px 12px 12px;
      background:linear-gradient(180deg, rgba(18,30,62,0.96), rgba(2,5,13,0.98));
      border-radius:0 0 20px 20px;
      border-top:1px solid rgba(110,246,255,0.25);
    }

    .gate-btn{
      min-width:160px;
      height:58px;
      border-radius:16px;
      display:flex;
      align-items:center;
      justify-content:center;
      font-weight:900;
      cursor:grab;
      border:1px solid rgba(255,255,255,0.18);
      user-select:none;
      font-size:12px;
      text-transform:uppercase;
      letter-spacing:0.06em;
      touch-action:none;
    }

    .gate-btn.blue{
      background:linear-gradient(135deg,#3fb3ff,#6ef6ff);
      color:#001;
    }
    .gate-btn.green{
      background:linear-gradient(135deg,#b7ffdf,#9cffb6);
      color:#001;
    }
    .gate-btn.orange{
      background:linear-gradient(135deg,#ffc88f,#ffb36b);
      color:#001;
    }

    /* Thin vertical gate placed on lanes */

    .lane-gate{
      position:absolute;
      width:120px;
      height:56px;
      display:flex;
      flex-direction:column;
      align-items:center;
      justify-content:center;
      background:transparent;
      border:none;
      pointer-events:none;
    }

    .lane-gate-line{
      width:9px;
      height:100%;
      border-radius:999px;
      box-shadow:0 0 18px rgba(110,246,255,0.3);
    }

    /* Color variants per test type */
    .lane-gate-unit .lane-gate-line{
      background:linear-gradient(180deg,#3fb3ff,#6ef6ff);
    }

    .lane-gate-contract .lane-gate-line{
      background:linear-gradient(180deg,#b7ffdf,#9cffb6);
    }

    .lane-gate-integration .lane-gate-line{
      background:linear-gradient(180deg,#ffc88f,#ffb36b);
    }

    .lane-gate-label{
      margin-top:4px;
      font-size:9px;
      letter-spacing:0.04em;
      text-transform:uppercase;
      opacity:0.9;
    }

    /* Leaderboard container (hidden in main screen) */

    .lb{
      margin-top:6px;
      background:rgba(255,255,255,0.03);
      padding:8px;
      border-radius:12px;
      max-height:180px;
      overflow:auto;
    }

    .muted{
      opacity:0.8;
    }

    .wave-banner{
      position:absolute;
      left:50%;
      transform:translateX(-50%);
      top:10px;
      background:rgba(0,0,0,0.5);
      padding:6px 12px;
      border-radius:999px;
      color:#e9ffff;
      font-weight:700;
      border:1px solid rgba(110,246,255,0.25);
      font-size:12px;
    }

    /* PROD health / damage states */

    .prod-column.healthy .prod-crack{
      border-color: rgba(110,246,255,0.6);
      box-shadow:0 0 14px rgba(110,246,255,0.65) inset;
    }
    .prod-column.healthy{
      animation:prod-pulse 2.5s ease-in-out infinite;
    }

    .prod-column.hit{
      animation: prod-hit 0.35s ease-out;
    }

    .prod-column.damaged .prod-crack{
      border-color: rgba(255,200,120,0.7);
      box-shadow:0 0 14px rgba(255,140,60,0.5) inset;
    }

    .prod-column.critical .prod-crack{
      border-color: rgba(255,80,80,0.95);
      box-shadow:0 0 16px rgba(255,80,80,0.7) inset;
    }

    .prod-column.broken{
      animation: prod-break 0.6s ease-out forwards;
      filter:grayscale(1) brightness(0.6);
    }

    /* subtle healthy pulse */
    @keyframes prod-pulse{
      0%,100% { box-shadow:0 10px 25px rgba(0,0,0,0.6); }
      50% { box-shadow:0 18px 35px rgba(0,0,0,0.8); }
    }

    /* small shake when PROD is hit */
    @keyframes prod-hit{
      0%  { transform:translateX(0); }
      20% { transform:translateX(-3px); }
      40% { transform:translateX(4px); }
      60% { transform:translateX(-2px); }
      80% { transform:translateX(2px); }
      100%{ transform:translateX(0); }
    }

    /* breakdown when health reaches 0 */
    @keyframes prod-break{
      0%  { transform:scale(1);   opacity:1;   }
      40% { transform:scale(1.04) rotate(1deg);  opacity:0.8; }
      70% { transform:scale(0.98) rotate(-2deg); opacity:0.5; }
      100%{ transform:scale(0.96) rotate(-4deg); opacity:0.3; }
    }

    /* Misc */
    @keyframes pop {
      0%{transform:scale(.9)}
      50%{transform:scale(1.06)}
      100%{transform:scale(1)}
    }

    /* End-of-game / start overlay */

    .end-overlay{
      position:fixed;
      inset:0;
      display:flex;
      align-items:center;
      justify-content:center;
      background:
        radial-gradient(circle at 50% 20%, rgba(255,255,255,0.12), transparent 55%),
        linear-gradient(180deg,rgba(0,0,0,0.85),rgba(0,0,0,0.95));
      z-index:120;
    }

    .end-card{
      background:linear-gradient(180deg,#071022,#030712);
      border-radius:24px;
      border:1px solid rgba(110,246,255,0.6);
      padding:24px 28px 20px;
      min-width:280px;
      max-width:360px;
      text-align:center;
      box-shadow:0 20px 60px rgba(0,0,0,0.8);
    }

    .end-title{
      font-size:26px;
      font-weight:900;
      letter-spacing:0.12em;
      text-transform:uppercase;
      margin-bottom:8px;
      text-shadow:0 0 18px rgba(255,255,255,0.6);
      animation:end-title-pop 0.7s ease-out;
    }

    .end-score{
      font-size:18px;
      margin-bottom:4px;
    }

    .end-rank{
      font-size:14px;
      opacity:0.9;
      margin-bottom:14px;
    }

    .end-actions{
      display:flex;
      justify-content:center;
      gap:10px;
      margin-top:4px;
    }

    .end-actions button{
      font-size:13px;
      font-weight:700;
      padding:8px 14px;
    }

    /* name input in start overlay */
    .name-input{
      width:100%;
      margin:10px 0 6px;
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(110,246,255,0.6);
      background:rgba(0,0,0,0.55);
      color:#e8f7ff;
      outline:none;
      font-family:inherit;
      font-size:14px;
    }
    .name-input::placeholder{
      color:rgba(232,247,255,0.55);
    }
    .name-input:focus{
      border-color:rgba(110,246,255,0.95);
      box-shadow:0 0 0 2px rgba(110,246,255,0.5);
    }

    .end-actions button[disabled]{
      opacity:0.4;
      cursor:not-allowed;
    }

    /* special colors */
    .end-title.meltdown{
      color:#ff8a6b;
    }
    .end-title.timeup{
      color:#6ef6ff;
    }

    /* animated wobble */
    @keyframes end-title-pop{
      0%   { transform:scale(0.6) rotate(-4deg); opacity:0; }
      40%  { transform:scale(1.1) rotate(2deg);  opacity:1; }
      70%  { transform:scale(0.96) rotate(-2deg);}
      100% { transform:scale(1)   rotate(0deg); }
    }

    /* Modal (tutorial / leaderboard) */
    .modal-root{
      position:fixed;
      inset:0;
      align-items:center;
      justify-content:center;
      background:linear-gradient(180deg,rgba(0,0,0,0.65),rgba(0,0,0,0.9));
      z-index:110;
      display:none;
    }

    .modal-content{
      background:linear-gradient(180deg,#071022,#04101a);
      padding:18px;
      border-radius:16px;
      border:1px solid rgba(110,246,255,0.4);
      width:720px;
      max-width:95vw;
      color:#dff;
      box-shadow:0 18px 50px rgba(0,0,0,0.9);
    }

    /* Leaderboard table styling inside modal */
    .lb-table{
      width:100%;
      border-collapse:collapse;
      margin-top:8px;
      font-size:14px;
    }
    .lb-table th,
    .lb-table td{
      padding:6px 8px;
    }
    .lb-table th{
      text-align:left;
      font-size:12px;
      text-transform:uppercase;
      opacity:0.7;
      border-bottom:1px solid rgba(255,255,255,0.2);
    }
    .lb-row{
      border-bottom:1px solid rgba(255,255,255,0.06);
    }
    .lb-row:nth-child(even){
      background:rgba(255,255,255,0.01);
    }
    .lb-row.me{
      background:rgba(110,246,255,0.09);
    }
    .lb-row.top1 td{
      color:#ffd86b;
    }
    .lb-row.top2 td{
      color:#bce3ff;
    }
    .lb-row.top3 td{
      color:#c9ffb0;
    }

    .lb-medal{
      font-size:16px;
      width:28px;
    }

    /* footer tip */

    .footer-tip{
      width:98%;
      max-width:1400px;
      color:#cfffe3;
      margin-top:6px;
      font-size:13px;
      background:linear-gradient(90deg,rgba(2,37,27,0.9),rgba(4,14,25,0.95));
      border-radius:999px;
      padding:8px 16px;
      border:1px solid rgba(110,246,255,0.2);
      box-shadow:0 8px 18px rgba(0,0,0,0.7);
    }

    /* Responsive tweaks */

    @media (max-width:900px){
      .gate-btn {
        min-width:0 !important;
        width:auto;
        height:auto;
        border-radius:12px;
        display:flex;
        align-items:center;
        justify-content:center;
        font-weight:900;
        cursor:grab;
        border:1px solid rgba(255,255,255,0.18);
        user-select:none;
        padding:6px 8px;
      }
      .game-area{height:420px}
      header{
        flex-direction:column;
        align-items:flex-start;
        gap:8px;
      }
    }

    /* Smaller type on very small screens */
    @media (max-width:600px){
      .title-main{font-size:22px;}
      .gate-bar{flex-wrap:wrap;}
    }

    @media (max-width: 520px) {
      body {
        padding: 0;
        margin: 0;
        overflow-x: hidden;
      }

      .wrap {
        margin: 0;
        padding: 8px;
        border-radius: 0;
      }

      header {
        gap: 6px;
      }

      .controls {
        flex-wrap: wrap;
        gap: 6px;
      }

      .game-area {
        padding: 8px;
        min-height: 420px;
      }

      .lanes {
        margin: 40px 0 20px 0;
        gap: 6px;
      }

      .lane {
        border-width: 1px;
        min-height: 36px;
      }

      .gate-bar {
        flex-direction: column;
      }

      .gate-btn {
        padding: 10px;
        font-size: 14px;
      }

      .wave-banner {
        font-size: 11px;
      }

      .bug {
        font-size: 10px;
        padding: 2px 6px;
      }
    }

    .lane {
      touch-action:none;
    }
/* ---------- MOBILE MODE: vertical lanes, PROD as horizontal bar, icon-only bug ---------- */
@media (max-width: 600px) {

  html,body{
    height:100%;
    overflow:hidden;        /* no vertical scroll */
  }

  .wrap{
    height:100%;
    padding:8px;
    box-sizing:border-box;
  }

  .main{
    flex:1;
    display:flex;
    flex-direction:column;
    gap:8px;
  }

  .game-area{
    flex:1;
    min-height:0;
    display:flex;
    flex-direction:column;
    padding-bottom:0;
  }

  .lanes{
    position:static;
    order:1;
    display:flex;
    flex-direction:row;
    flex:1;
    width:100%;
    margin:32px 0 4px 0;    /* space under banner */
    gap:6px;
  }

  .lane{
    flex:1;
    min-width:60px;
    margin:0 4px;
  }

  .lane .line-left{
    display:none;
  }

  .lane::before{
    content:'';
    position:absolute;
    top:10px;
    left:0;
    right:0;
    height:3px;
    background:linear-gradient(90deg, var(--neon-cyan), transparent);
    opacity:0.8;
    border:none;
    box-shadow:none;
  }

  /* PROD becomes a horizontal pill under the lanes */
  .prod-column{
    position:relative;
    order:2;
    top:0;
    right:0;
    margin:4px auto 0;
    width:220px;
    height:72px;
    flex-direction:row;
    justify-content:space-between;
    align-items:center;
    padding:10px 14px;
  }
  .prod-icon{
    font-size:26px;
    margin-bottom:0;
  }
  .prod-label{
    font-size:11px;
  }
  .health{
    width:110px;
  }

  .wave-banner{
    top:4px;
  }

  .gate-bar{
    order:3;
    border-radius:0 0 20px 20px;
    flex-wrap:wrap;
  }

  /* BUG: icon only on mobile */
  .bug span:last-child{
    display:none;
  }
}

  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>
      <span class="title-main">CI/CD</span>
      <span class="title-sub">Defense Arcade</span>
    </h1>
    <div class="controls">
      <div class="pill pill-player">
        <span class="pill-label">Player</span>
        <span id="playerName" class="pill-value">‚Äî</span>
      </div>
      <div class="pill pill-score">
        <span class="pill-label">Score</span>
        <span id="score" class="pill-value">0</span>
      </div>
      <div class="pill pill-combo">
        <span class="pill-label">Combo</span>
        <span id="combo" class="pill-value">0</span>
      </div>
      <button id="btnStart" class="btn-primary">‚ñ∂ Start</button>
      <button id="btnAbort" disabled>Abort</button>
      <button id="btnLB" class="btn-secondary">üèÜ Leaderboard</button>
      <button id="btnTutorial" class="btn-secondary">‚ùì Tutorial</button>
    </div>
  </header>

  <div class="main">
    <div class="hud">
      <div class="hud-chip">
        <span class="hud-label">Mode</span>
        <span class="hud-value" id="modeLbl">Classic (single)</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Upcoming</span>
        <span class="hud-value" id="upcoming">‚Äî</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Remaining</span>
        <span class="hud-value" id="remaining">‚Äî</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Speed</span>
        <span class="hud-value" id="speedLbl">1.00x</span>
      </div>
      <div class="hud-chip hud-chip-timer">
        <span class="hud-label">Time</span>
        <span class="hud-value" id="timer">90</span><span class="hud-unit">s</span>
      </div>
    </div>

    <div class="game-area" id="gameArea">
      <div class="grid"></div>
      <div class="wave-banner" id="banner">Ready</div>
      <div class="lanes" id="lanes"></div>

      <div class="prod-column healthy" id="prodCol">
        <div class="prod-crack" id="prodCrack"></div>
        <div class="prod-icon">‚öôÔ∏è</div>
        <div class="prod-label">PROD</div>
        <div class="health" title="Production Stability">
          <div id="healthInner" class="health-inner"></div>
        </div>
      </div>

      <!-- End-of-game overlay -->
      <div id="endOverlay" class="end-overlay" style="display:none">
        <div class="end-card">
          <div id="endTitle" class="end-title">Time Up!</div>
          <div id="endScore" class="end-score">Score: 0</div>
          <div id="endRank" class="end-rank"></div>
          <div class="end-actions">
            <button id="endBtnPlay">Play Again</button>
            <button id="endBtnLB">View Leaderboard</button>
            <button id="endBtnNew">New Game</button>
          </div>
        </div>
      </div>

      <!-- Start-of-game overlay (kids game effect + name input) -->
      <div id="startOverlay" class="end-overlay" style="display:flex">
        <div class="end-card">
          <div id="startTitle" class="end-title timeup">
            CI/CD Defense Arcade
          </div>
          <div id="startSubtitle" class="end-score">
            Defend PROD from sneaky CI/CD bugs!
          </div>

          <input id="playerNameInput"
                 type="text"
                 class="name-input"
                 placeholder="Type your hero name here" />

          <div class="end-rank">
            Drag UNIT / CONTRACT / INTEGRATION gates onto builds to stop bugs early.
          </div>
          <div class="end-actions">
            <button id="startOverlayBtn" disabled>Start Game ‚ñ∂</button>
          </div>
        </div>
      </div>
    </div>

    <!-- Gate bar -->
    <div class="gate-bar" id="gateBar">
      <div class="gate-btn blue" draggable="true" data-type="unit">UNIT TEST</div>
      <div class="gate-btn green" draggable="true" data-type="contract">CONTRACT TEST</div>
      <div class="gate-btn orange" draggable="true" data-type="integration">INTEGRATION</div>
    </div>

    <!-- Hidden leaderboard & controls (used only by JS) -->
    <div style="display:flex;gap:12px;align-items:flex-start">
      <div id="lbPanel" style="flex:1;display:none">
        <div class="muted">Leaderboard</div>
        <div class="lb" id="lb"></div>
      </div>

      <div id="controlsPanel"
           style="width:260px;margin-left:auto;display:none">
        <div class="muted">Controls</div>
        <div style="display:flex;flex-direction:column;gap:8px;margin-top:8px">
          <button id="spawnBtn">Spawn Next Bug</button>
          <button id="resetBtn">Reset Session</button>
          <button id="clearLb">Clear Scores</button>
        </div>
      </div>
    </div>
  </div>

  <footer class="footer-tip">
    üí° Tip:
    Drag a gate up from the bottom bar and drop it onto a lane.
    Correct gate blocks the bug for <b>+50 to +250 points</b> (earlier in the pipeline = more points).
    Wrong gate pauses the bug 0.5s and costs ‚àí100.
    Bug reaching PROD costs ‚àí500 and damages production. 5 hits = full PROD meltdown.
  </footer>
</div>

<!-- Modal (for tutorial + leaderboard) -->
<div id="modal" class="modal-root">
  <div class="modal-content" id="modalContent"></div>
</div>

<script>
/* ---------- Config & State ---------- */
let timerInterval = null;
const GAME_DURATION = 90; // seconds

const CONFIG = {
  lanes: 5,
  totalBugs: 75,
  bugTravelSeconds: 15,
  prodMax: 100,
  wrongPauseMs: 500,
  scoring: {
    correctMax: 250,
    correctMin: 50,
    wrongGate: -100,
    hitProd: -500,
    comboBonus: 1000,
    comboSize: 3
  }
};

/* ---------- Firebase base URL (Realtime DB REST) ---------- */
const FIREBASE_DB_URL = 'https://roadshowgame-default-rtdb.firebaseio.com';

/* Save a score to Firebase (POST to /scores) */
async function saveScoreToFirebase(name, score, timestamp) {
  try {
    const res = await fetch(`${FIREBASE_DB_URL}/scores.json`, {
      method: 'POST',
      headers: { 'Content-Type': 'application/json' },
      body: JSON.stringify({ name, score, timestamp })
    });
    const data = await res.json();
    console.log('Score saved to Firebase:', data);
    return data && data.name; // key
  } catch (err) {
    console.error('Error saving score to Firebase:', err);
    return null;
  }
}

/* Read leaderboard scores from Firebase */
async function fetchLeaderboardFromFirebase() {
  try {
    const res = await fetch(`${FIREBASE_DB_URL}/scores.json`);
    const data = await res.json();
    if (!data) return [];

    const rows = Object.entries(data).map(([id, entry]) => ({
      id,
      name: entry.name || 'Anon',
      score: typeof entry.score === 'number'
        ? entry.score
        : parseInt(entry.score, 10) || 0,
      timestamp: entry.timestamp || 0
    }));

    rows.sort((a, b) => b.score - a.score);
    return rows.slice(0, 20);
  } catch (err) {
    console.error('Error loading leaderboard from Firebase:', err);
    return [];
  }
}

/* Render small leaderboard panel on main screen */
async function renderLB() {
  const a = await fetchLeaderboardFromFirebase();
  const lbBox = document.getElementById('lb');
  lbBox.innerHTML = a.length
    ? a.map(r => `
        <div style="display:flex;justify-content:space-between;padding:6px;border-bottom:1px solid rgba(255,255,255,0.04)">
          <div>${r.name}</div>
          <div style="opacity:.85">${r.score}</div>
        </div>`).join('')
    : '<div style="opacity:.75;padding:8px">No scores yet</div>';
}
renderLB();

/* ---------- State ---------- */
let state = {
  player: null,
  score: 0,
  combo: 0,
  health: CONFIG.prodMax,
  currentBug: null,
  remaining: CONFIG.totalBugs,
  spawnedCount: 0,
  running: false
};

/* ---------- DOM refs ---------- */
const lanesEl        = document.getElementById('lanes');
const gameArea       = document.getElementById('gameArea');
const banner         = document.getElementById('banner');
const healthInner    = document.getElementById('healthInner');
const scoreEl        = document.getElementById('score');
const comboEl        = document.getElementById('combo');
const remainingEl    = document.getElementById('remaining');
const upcomingEl     = document.getElementById('upcoming');
const speedLbl       = document.getElementById('speedLbl');
const modeLbl        = document.getElementById('modeLbl');
const lbBox          = document.getElementById('lb');
const playerNameEl   = document.getElementById('playerName');

const spawnBtn       = document.getElementById('spawnBtn');
const resetBtn       = document.getElementById('resetBtn');
const clearLbBtn     = document.getElementById('clearLb');
const btnStart       = document.getElementById('btnStart');
const btnLB          = document.getElementById('btnLB');
const btnTutorial    = document.getElementById('btnTutorial');
const prodCol        = document.getElementById('prodCol');

const endOverlay     = document.getElementById('endOverlay');
const endTitleEl     = document.getElementById('endTitle');
const endScoreEl     = document.getElementById('endScore');
const endRankEl      = document.getElementById('endRank');
const endBtnPlay     = document.getElementById('endBtnPlay');
const endBtnLB       = document.getElementById('endBtnLB');
const endBtnNew      = document.getElementById('endBtnNew');

const startOverlay    = document.getElementById('startOverlay');
const startOverlayBtn = document.getElementById('startOverlayBtn');
const playerNameInput = document.getElementById('playerNameInput');

/* ---------- Utility: desktop vs mobile ---------- */
function isMobileMode() {
  return window.innerWidth < 600;
}

/* ---------- Build lanes ---------- */
function buildLanes() {
  lanesEl.innerHTML = '';
  for (let i = 0; i < CONFIG.lanes; i++) {
    const lane = document.createElement('div');
    lane.className = 'lane';
    lane.dataset.index = i;

    const label = document.createElement('div');
    label.className = 'lane-label';
    label.textContent = `Build ${i + 1}`;
    lane.appendChild(label);

    lane.innerHTML += `<div class='line-left'></div>`;
    lanesEl.appendChild(lane);
  }
}
buildLanes();

/* ---------- Bug pool ---------- */
const BUG_POOL = (function () {
  const seeds = [
    // unit-ish
    'Off-by-one error','Wrong variable type','Null pointer in util','GST calc wrong','Rounding mismatch',
    'Missing validation','Incorrect loop bound','Uninitialized var','Edge-case divide by zero','Wrong default value',
    'Wrong comparator','Floating precision bug','Wrong sign on calculation','Index out of range','Incorrect accumulator',
    'Wrong math formula','Missing unit test','Order of operations bug','Bad regex logic','Wrong constant used',
    'Locale number parse bug','Time-zone handling bug','Incorrect flag check','State mutation bug','Callback misuse',
    // contract-ish
    'API contract mismatch','Missing response field','Wrong HTTP status','Schema version mismatch','Field type mismatch',
    'Unexpected null in response','Header missing','Wrong content-type','Response shape changed','Deprecated field used',
    'Payload key typo','Missing required param','Extra field in response','Versioning mismatch','Incorrect enum value',
    'Invalid JSON format','Missing validation in schema','Query param name typo','Incorrect date format','Wrong pagination format',
    'Incorrect status code mapping','Auth header name mismatch','Field maxLength exceeded','Wrong field encoding','Trailing comma in response',
    // integration-ish
    'DB query fails intermittently','Config missing in CI','Container env mismatch','Service timeout in cluster','Race condition across services',
    'Circuit breaker not set','Retry logic missing','Downstream API latency','Wrong endpoint routing','Auth token refresh failure',
    'Network partition issue','Load balancer misroute','Session stickiness lost','Wrong service discovery','SSL cert mismatch',
    'Timeout too low','Ordering of messages wrong','Transaction not rolled back','Cache invalidation bug','Feature flag not propagated',
    'Message queue DLQ spike','Throttling misconfigured','Cross-origin blocked','DNS propagation issue','Legacy endpoint hit'
  ];
  return seeds.map((t, idx) => ({
    id: 'b' + idx,
    label: t,
    right: idx < 25 ? 'unit' : idx < 50 ? 'contract' : 'integration',
    icon: 'üêû'
  }));
})();

function shuffle(a) {
  for (let i = a.length - 1; i > 0; i--) {
    const j = Math.floor(Math.random() * (i + 1));
    [a[i], a[j]] = [a[j], a[i]];
  }
  return a;
}
let bugQueue = shuffle([...BUG_POOL]);
function getNextBugDef() {
  if (bugQueue.length === 0) bugQueue = shuffle([...BUG_POOL]);
  return bugQueue.shift();
}

/* ---------- Audio helper ---------- */
function beep(freq = 440, dur = 0.06) {
  try {
    const Ctx = window.AudioContext || window.webkitAudioContext;
    const ctx = new Ctx();
    const o = ctx.createOscillator(), g = ctx.createGain();
    o.connect(g); g.connect(ctx.destination);
    o.frequency.value = freq;
    o.start();
    g.gain.setValueAtTime(0.0001, ctx.currentTime);
    g.gain.exponentialRampToValueAtTime(0.12, ctx.currentTime + 0.01);
    g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime + dur);
    o.stop(ctx.currentTime + dur + 0.02);
  } catch (e) {}
}

/* ---------- UI helpers ---------- */
function updateHUD() {
  scoreEl.textContent = state.score;
  comboEl.textContent = state.combo;
  remainingEl.textContent = state.remaining;
  const speedFactor = 1 + (state.spawnedCount * 0.12);
  speedLbl.textContent = speedFactor.toFixed(2) + 'x';
  upcomingEl.textContent = state.currentBug ? state.currentBug.def.label : '‚Äî';
  modeLbl.textContent = isMobileMode()
    ? `Mobile (vertical, ${CONFIG.lanes} builds)`
    : `Classic (horizontal, ${CONFIG.lanes} builds)`;
}

function updateHealth() {
  const pct = Math.max(0, Math.floor((state.health / CONFIG.prodMax) * 100));
  healthInner.style.width = pct + '%';
  if (pct < 30) {
    healthInner.style.background = 'linear-gradient(90deg,#ff6b6b,#ff8a3d)';
  } else {
    healthInner.style.background = 'linear-gradient(90deg,var(--neon-green),var(--neon-cyan))';
  }
}

function updateProdDamageVisual() {
  prodCol.classList.remove('healthy', 'damaged', 'critical', 'broken');
  if (state.health <= 0) {
    prodCol.classList.add('broken', 'critical', 'damaged');
  } else if (state.health <= 30) {
    prodCol.classList.add('critical', 'damaged');
  } else if (state.health <= 70) {
    prodCol.classList.add('damaged');
  } else {
    prodCol.classList.add('healthy');
  }
}

function flashBanner(text, ms = 900) {
  const old = banner.textContent;
  banner.textContent = text;
  banner.style.animation = 'pop 0.4s ease-out';
  setTimeout(() => {
    banner.textContent = old;
    banner.style.animation = '';
  }, ms);
}

/* Floating score text */
function showFloatingText(text, x, y, color) {
  const node = document.createElement('div');
  node.textContent = text;
  node.style.position = 'absolute';
  node.style.left = x + 'px';
  node.style.top = y + 'px';
  node.style.color = color || '#fff';
  node.style.fontWeight = '700';
  node.style.fontSize = '16px';
  node.style.textShadow = '0 0 8px rgba(0,0,0,0.7)';
  node.style.pointerEvents = 'none';
  node.style.zIndex = 80;
  gameArea.appendChild(node);

  node.animate(
    [
      { transform: 'translateY(0)', opacity: 1 },
      { transform: 'translateY(-30px)', opacity: 0 }
    ],
    { duration: 800, easing: 'ease-out' }
  );
  setTimeout(() => { try { node.remove(); } catch (e) {} }, 800);
}

/* ---------- Modal ---------- */
function showModal(html) {
  document.getElementById('modalContent').innerHTML = html;
  document.getElementById('modal').style.display = 'flex';
}
function hideModal() {
  document.getElementById('modal').style.display = 'none';
}

/* ---------- Tutorial & Buttons ---------- */
btnTutorial.addEventListener('click', () => {
  showModal(`
    <h2>How to Play</h2>
    <p>üêû One bug at a time spawns on a build lane. Drag a gate (UNIT / CONTRACT / INTEGRATION) and drop it onto a lane. The gate will snap and block the approaching bug.</p>
    <ul>
      <li><b>Correct gate</b> (matches bug type): +${CONFIG.scoring.correctMin} to +${CONFIG.scoring.correctMax} (earlier is better)</li>
      <li><b>Wrong gate</b>: ${CONFIG.scoring.wrongGate}, bug pauses ${CONFIG.wrongPauseMs}ms</li>
      <li><b>Bug hits PROD</b>: ${CONFIG.scoring.hitProd} and production health drops by 20% (5 hits = meltdown)</li>
      <li>Every ${CONFIG.scoring.comboSize} correct in a row gives a combo bonus of +${CONFIG.scoring.comboBonus}</li>
    </ul>
    <div style="text-align:right;margin-top:10px">
      <button onclick="hideModal()">Got it!</button>
    </div>
  `);
});

/* Fancy leaderboard modal ‚Äì now from Firebase */
btnLB.addEventListener('click', async () => {
  const globalRows = await fetchLeaderboardFromFirebase();
  const localRows = loadLocalScores();

  if (!window._lbMode) window._lbMode = "global";

  function renderTable(mode) {
    const rows = mode === "global" ? globalRows : localRows;
    const isGlobal = (mode === "global");

    if (!rows.length) {
      return `
        <p style="opacity:.7;margin-top:12px">
          ${isGlobal ? "No global scores yet." : "No personal scores found on this device."}
        </p>`;
    }

    return `
      <table class="lb-table">
        <thead>
          <tr>
            <th style="width:40px">#</th>
            <th>Player</th>
            <th style="text-align:right">Score</th>
          </tr>
        </thead>
        <tbody>
          ${rows.map((r, i) => `
            <tr class="lb-row">
              <td>${i + 1}</td>
              <td>${r.name}</td>
              <td style="text-align:right">${r.score}</td>
            </tr>
          `).join("")}
        </tbody>
      </table>
    `;
  }

  window._renderLBFull = function () {
    const mode = window._lbMode;
    return `
      <h2>üèÜ Leaderboard</h2>

      <div style="display:flex;gap:12px;margin-bottom:14px">
        <button class="btn-secondary"
          style="border:${mode==='global'?'2px solid #6ef6ff':'1px solid rgba(255,255,255,0.2)'}"
          onclick="window._lbMode='global'; document.getElementById('modalContent').innerHTML = window._renderLBFull()">
          üåê Global
        </button>

        <button class="btn-secondary"
          style="border:${mode==='local'?'2px solid #6ef6ff':'1px solid rgba(255,255,255,0.2)'}"
          onclick="window._lbMode='local'; document.getElementById('modalContent').innerHTML = window._renderLBFull()">
          üíæ My Scores
        </button>
      </div>

      <div id="lbContent">
        ${renderTable(mode)}
      </div>

      <div style="text-align:right;margin-top:16px">
        <button onclick="hideModal()">Close</button>
      </div>
    `;
  };

  showModal(window._renderLBFull());
});

/* Clear leaderboard ‚Äì deletes /scores in Firebase */
clearLbBtn.addEventListener('click', async () => {
  try {
    await fetch(`${FIREBASE_DB_URL}/scores.json`, { method: 'DELETE' });
  } catch (e) {
    console.error('Error clearing Firebase leaderboard', e);
  }
  renderLB();
});

resetBtn.addEventListener('click', resetSession);
spawnBtn.addEventListener('click', () => spawnNextBug(true));

/* ---------- Name input behaviour ---------- */
playerNameInput.addEventListener('input', () => {
  const val = playerNameInput.value.trim();
  startOverlayBtn.disabled = !val;
});

/* ---------- Drag & Drop (lanes) ---------- */
let drag = null;
document.querySelectorAll('.gate-btn').forEach(g => {
  g.addEventListener('dragstart', (e) => {
    drag = { type: g.dataset.type };
    g.classList.add('dragging');
    e.dataTransfer.setData('text', 'gate');
  });
  g.addEventListener('dragend', () => {
    drag = null;
    document.querySelectorAll('.gate-btn').forEach(x => x.classList.remove('dragging'));
  });
});

gameArea.addEventListener('dragover', (e) => {
  e.preventDefault();
  const lanesRect = lanesEl.getBoundingClientRect();
  const mainAxis = isMobileMode() ? (e.clientX - lanesRect.left) : (e.clientY - lanesRect.top);
  const laneSize = (isMobileMode() ? lanesRect.width : lanesRect.height) / CONFIG.lanes;
  const idx = Math.max(0, Math.min(CONFIG.lanes - 1, Math.floor(mainAxis / laneSize)));
  document.querySelectorAll('.lane').forEach((el, i) => el.classList.toggle('lane-hover', i === idx));
});

gameArea.addEventListener('drop', (e) => {
  e.preventDefault();
  document.querySelectorAll('.lane').forEach(el => el.classList.remove('lane-hover'));
  if (!drag || !state.running || !state.currentBug) {
    drag = null;
    return;
  }
  const lanesRect = lanesEl.getBoundingClientRect();
  const mainAxis = isMobileMode() ? (e.clientX - lanesRect.left) : (e.clientY - lanesRect.top);
  const laneSize = (isMobileMode() ? lanesRect.width : lanesRect.height) / CONFIG.lanes;
  const chosen = Math.max(0, Math.min(CONFIG.lanes - 1, Math.floor(mainAxis / laneSize)));

  const areaRect = gameArea.getBoundingClientRect();
const coord = isMobileMode()
  ? touch.clientY - areaRect.top
  : touch.clientX - areaRect.left;
  placeGate(drag.type, chosen, coord);
  drag = null;
});

/* ---------- Gate placement (1D along path) ---------- */
function placeGate(type, laneIndex, clientPos) {
  if (!state.currentBug) return;

  const areaRect = gameArea.getBoundingClientRect();
  const laneEl = lanesEl.children[laneIndex];
  const laneRect = laneEl.getBoundingClientRect();

  const node = document.createElement('div');
  node.className = 'lane-gate lane-gate-' + type;
  node.style.zIndex = 60;

  const line = document.createElement('div');
  line.className = 'lane-gate-line';
  const label = document.createElement('div');
  label.className = 'lane-gate-label';
  label.textContent = type.toUpperCase();
  node.appendChild(line);
  node.appendChild(label);

  gameArea.appendChild(node);

  let pathPos;
  let left, top;

  if (isMobileMode()) {
    const laneCenterX = laneRect.left - areaRect.left + laneRect.width / 2;
    const gateWidth = node.offsetWidth || 120;
    const halfW = gateWidth / 2;
    left = laneCenterX - halfW;

    const minY = laneRect.top - areaRect.top + 30;
    const maxY = laneRect.bottom - areaRect.top - 30;
    pathPos = clientPos - areaRect.top;
    pathPos = Math.max(minY, Math.min(maxY, pathPos));
    top = pathPos - (node.offsetHeight || 56) / 2;
  } else {
    const laneCenterY = laneRect.top - areaRect.top + laneRect.height / 2;
    const gateWidth = node.offsetWidth || 120;
    const halfW = gateWidth / 2;

    let gateCenter = clientPos - areaRect.left;
    gateCenter = Math.max(halfW, Math.min(gateCenter, areaRect.width - halfW));
    left = gateCenter - halfW;
    top = laneCenterY - (node.offsetHeight || 56) / 2;
    pathPos = gateCenter;
  }

  node.style.left = left + 'px';
  node.style.top  = top  + 'px';

  if (!window._placedGates) window._placedGates = [];
  window._placedGates.push({
    el: node,
    type,
    lane: laneIndex,
    pathPos,
    consumed: false
  });

  node.animate(
    [{ transform: 'scale(.86)' }, { transform: 'scale(1.02)' }, { transform: 'scale(1)' }],
    { duration: 220 }
  );
  beep(520, 0.06);
}

/* ---------- Bug spawn / movement ---------- */
function spawnNextBug(manual = false) {
  if (!state.running) return;
  if (state.currentBug) return;
  if (state.remaining <= 0) {
    if (manual) flashBanner('No bugs remaining');
    return;
  }

  const def = getNextBugDef();
  const laneIndex = Math.floor(Math.random() * CONFIG.lanes);
  const laneEl = lanesEl.children[laneIndex];
  const areaRect = gameArea.getBoundingClientRect();
  const laneRect = laneEl.getBoundingClientRect();

  const el = document.createElement('div');
  el.className = 'bug';
  el.innerHTML = `<span class="icon">${def.icon}</span><span>${def.label}</span>`;
  el.style.left = '0px';
  el.style.top = '0px';
  el.style.zIndex = 40;
  gameArea.appendChild(el);

  const bugW = el.offsetWidth;
  const bugH = el.offsetHeight;

  let bug;
  if (isMobileMode()) {
    const lineOffsetY = 10;
    const startY = (laneRect.top - areaRect.top) + lineOffsetY;
    const x = laneRect.left - areaRect.left + laneRect.width / 2 - bugW / 2;

    const prodRect = prodCol.getBoundingClientRect();
    const prodThreshold = prodRect.top - areaRect.top - bugH;
    const distance = prodThreshold - startY;
    const speed = distance / CONFIG.bugTravelSeconds;

    el.style.left = x + 'px';
    el.style.top  = startY + 'px';

    bug = {
      def,
      row: laneIndex,
      el,
      x,
      y: startY,
      vx: 0,
      vy: speed,
      pausedUntil: 0,
      active: true,
      pathStart: startY,
      pathEnd: prodThreshold
    };
  } else {
    const lineOffset = 10;
    const startX = (laneRect.left - areaRect.left) + lineOffset;
    const y = laneRect.top - areaRect.top + laneRect.height / 2 - bugH / 2;

    const prodRect = prodCol.getBoundingClientRect();
    const prodThreshold = prodRect.left - areaRect.left - bugW;
    const distance = prodThreshold - startX;
    const speed = distance / CONFIG.bugTravelSeconds;

    el.style.left = startX + 'px';
    el.style.top  = y + 'px';

    bug = {
      def,
      row: laneIndex,
      el,
      x: startX,
      y,
      vx: speed,
      vy: 0,
      pausedUntil: 0,
      active: true,
      pathStart: startX,
      pathEnd: prodThreshold
    };
  }

  state.currentBug = bug;
  state.spawnedCount++;
  state.remaining--;

  upcomingEl.textContent = def.label;
  updateHUD();

  const gateName =
    def.right === 'unit'        ? 'UNIT TEST' :
    def.right === 'contract'    ? 'CONTRACT TEST' :
    def.right === 'integration' ? 'INTEGRATION' :
    def.right.toUpperCase();

  banner.textContent = `Incoming: ${def.label} (${gateName})`;
}

/* Dynamic score based on gate position along bug path */
function computeDynamicScore(gatePos, bug) {
  const maxScore = CONFIG.scoring.correctMax;
  const minScore = CONFIG.scoring.correctMin;
  const start = bug.pathStart;
  const end   = bug.pathEnd;
  const span  = Math.max(end - start, 1);

  let t = (gatePos - start) / span;
  t = Math.min(Math.max(t, 0), 1);
  const score = Math.round(maxScore - t * (maxScore - minScore));
  return score;
}

function handleGateHit(bug, gate) {
  gate.consumed = true;

  const gx = gate.el.offsetLeft + 40;
  const gy = gate.el.offsetTop - 24;

  if (gate.type === bug.def.right) {
    const dynamicScore = computeDynamicScore(gate.pathPos, bug);

    state.score += dynamicScore;
    state.combo++;
    beep(800, 0.08);

    showFloatingText(`+${dynamicScore}`, gx, gy, '#6effa0');

    if (state.combo > 0 && state.combo % CONFIG.scoring.comboSize === 0) {
      state.score += CONFIG.scoring.comboBonus;
      showFloatingText(`+${CONFIG.scoring.comboBonus}`, gx + 10, gy - 26, '#ffd36b');
      flashBanner(`Combo! +${CONFIG.scoring.comboBonus}`);
    }

    bug.active = false;
    try { bug.el.remove(); } catch (e) {}
    try { gate.el.remove(); } catch (e) {}

    window._placedGates = (window._placedGates || []).filter(g => g !== gate);
    state.currentBug = null;
    updateHUD();

    spawnNextBug();
  } else {
    state.score += CONFIG.scoring.wrongGate;
    state.combo = 0;
    beep(180, 0.08);

    showFloatingText(`${CONFIG.scoring.wrongGate}`, gx, gy, '#ff6b6b');

    bug.pausedUntil = performance.now() + CONFIG.wrongPauseMs;

    gate.el.style.opacity = '0.25';
    setTimeout(() => {
      try { gate.el.remove(); } catch (e) {}
      window._placedGates = (window._placedGates || []).filter(g => g !== gate);
    }, 400);

    updateHUD();
  }
}

function createSpark(x, y, color) {
  const s = document.createElement('div');
  s.className = 'spark';
  s.style.left = x + 'px';
  s.style.top = y + 'px';
  s.style.color = color || '#ffb36b';
  gameArea.appendChild(s);
  s.animate(
    [
      { transform: 'scale(1)', opacity: 1 },
      { transform: 'scale(2)', opacity: 0 }
    ],
    { duration: 700, easing: 'ease-out' }
  );
  setTimeout(() => { try { s.remove(); } catch (e) {} }, 700);
}

function hitProd(bug) {
  state.score += CONFIG.scoring.hitProd;
  state.combo = 0;

  state.health -= 20;
  if (state.health < 0) state.health = 0;

  updateHealth();
  updateProdDamageVisual();
  beep(120, 0.12);

  const areaRect = gameArea.getBoundingClientRect();
  const prodRect = prodCol.getBoundingClientRect();
  const sx = prodRect.left - areaRect.left;
  const sy = (prodRect.top - areaRect.top) + 20;

  createSpark(sx, sy, '#ffb36b');
  showFloatingText(`${CONFIG.scoring.hitProd}`, sx + 10, sy - 18, '#ff6b6b');

  prodCol.classList.add('hit');
  setTimeout(() => prodCol.classList.remove('hit'), 350);

  if (state.health <= 0) {
    for (let i = 0; i < 4; i++) {
      setTimeout(() => {
        createSpark(
          sx + 10 + (Math.random() * 40 - 20),
          sy + (Math.random() * 30 - 15),
          '#ff6666'
        );
      }, i * 120);
    }
  }

  bug.active = false;
  try { bug.el.remove(); } catch (e) {}
  state.currentBug = null;
  updateHUD();

  if (state.health <= 0) {
    endGame('Production meltdown!');
  } else if (state.remaining <= 0) {
    endGame('All bugs processed.');
  } else {
    spawnNextBug();
  }
}

/* ---------- movement loop ---------- */
let lastTime = null;
function gameLoop(ts) {
  if (!lastTime) lastTime = ts;
  const dt = ts - lastTime;
  lastTime = ts;

  if (state.running && state.currentBug && state.currentBug.active) {
    const bug = state.currentBug;
    const now = performance.now();

    if (now >= bug.pausedUntil) {
      const dtSec = dt / 1000;

      if (isMobileMode()) {
        bug.y += bug.vy * dtSec;
        bug.el.style.top = bug.y + 'px';
      } else {
        bug.x += bug.vx * dtSec;
        bug.el.style.left = bug.x + 'px';
      }

      const pathHead = isMobileMode() ? bug.y : bug.x;
      const pathTail = pathHead + (isMobileMode() ? bug.el.offsetHeight : bug.el.offsetWidth);

      let gates = window._placedGates || [];
      for (const gate of gates) {
        if (gate.consumed) continue;
        if (gate.lane !== bug.row) continue;
        const gateHalf = isMobileMode() ? 16 : 12;
        const gateStart = gate.pathPos - gateHalf;
        const gateEnd   = gate.pathPos + gateHalf;
        if (pathTail >= gateStart && pathHead <= gateEnd) {
          handleGateHit(bug, gate);
          break;
        }
      }

      if (bug.active) {
        if (pathHead >= bug.pathEnd) {
          hitProd(bug);
        }
      }
    }
  }

  requestAnimationFrame(gameLoop);
}
requestAnimationFrame(gameLoop);

/* ---------- Game control ---------- */
function resetSession() {
  state.running = false;
  clearInterval(timerInterval);
  timerInterval = null;

  endOverlay.style.display = 'none';

  if (state.currentBug && state.currentBug.el) {
    try { state.currentBug.el.remove(); } catch (e) {}
  }
  state.currentBug = null;

  (window._placedGates || []).forEach(g => {
    try { g.el.remove(); } catch (e) {}
  });
  window._placedGates = [];

  state.score = 0;
  state.combo = 0;
  state.health = CONFIG.prodMax;
  state.remaining = CONFIG.totalBugs;
  state.spawnedCount = 0;

  document.getElementById('timer').textContent = GAME_DURATION;
  banner.textContent = 'Ready';
  updateHealth();
  updateProdDamageVisual();
  updateHUD();
}

function showEndOverlay(reason, rank) {
  let title = 'Game Over';
  let className = '';

  if (reason && reason.toLowerCase().includes('time')) {
    title = '‚è∞ Time Up!';
    className = 'timeup';
  } else if (reason && reason.toLowerCase().includes('meltdown')) {
    title = 'üî• Production Meltdown!';
    className = 'meltdown';
  } else {
    title = reason || 'Game Over';
  }

  endTitleEl.textContent = title;
  endTitleEl.classList.remove('timeup', 'meltdown');
  if (className) endTitleEl.classList.add(className);

  endScoreEl.textContent = `Score: ${state.score}`;

  if (rank) {
    if (rank === 1) {
      endRankEl.textContent = `üèÜ New High Score! You‚Äôre #1`;
    } else {
      endRankEl.textContent = `New leaderboard rank: #${rank}`;
    }
  } else {
    endRankEl.textContent = '';
  }

  endTitleEl.style.animation = 'none';
  void endTitleEl.offsetWidth;
  endTitleEl.style.animation = '';

  endOverlay.style.display = 'flex';
}

/* Now async because we talk to Firebase */
async function endGame(reason) {
  state.running = false;
  clearInterval(timerInterval);
  timerInterval = null;
  banner.textContent = reason || 'Game over';

  let name = state.player;
  if (!name) {
    showEndOverlay(reason, null);
    return;
  }

  const stamp = Date.now();
  let rank = null;

  try {
    await saveScoreToFirebase(state.player, state.score, stamp);
    const rows = await fetchLeaderboardFromFirebase();

    const idx = rows.findIndex(
      r => r.name === state.player &&
           r.score === state.score &&
           r.timestamp === stamp
    );
    rank = idx >= 0 ? idx + 1 : null;
  } catch (e) {
    console.error('Error updating Firebase leaderboard', e);
  }
  saveLocalScore(state.player, state.score, stamp);

  showEndOverlay(reason, rank);
  renderLB();
}

function beginGame() {
  resetSession();
  state.running = true;
  lastTime = null;

  let timeLeft = GAME_DURATION;
  document.getElementById('timer').textContent = timeLeft;
  timerInterval = setInterval(() => {
    timeLeft--;
    if (timeLeft < 0) timeLeft = 0;
    document.getElementById('timer').textContent = timeLeft;
    if (timeLeft <= 0) {
      clearInterval(timerInterval);
      timerInterval = null;
      if (state.running) {
        endGame('Time up!');
      }
    }
  }, 1000);

  spawnNextBug();
  btnAbort.disabled = false;
}

/* buttons in end overlay */
endBtnPlay.addEventListener('click', () => {
  if (state.player) {
    beginGame();
  } else {
    startOverlay.style.display = 'flex';
  }
});

endBtnLB.addEventListener('click', () => {
  endOverlay.style.display = 'none';
  btnLB.click();
});

/* New Game: go back to name popup */
endBtnNew.addEventListener('click', () => {
  endOverlay.style.display = 'none';
  resetSession();

  state.player = null;
  playerNameEl.textContent = '‚Äî';

  playerNameInput.value = '';
  startOverlayBtn.disabled = true;

  startOverlay.style.display = 'flex';
  playerNameInput.focus();
});

/* start overlay button */
startOverlayBtn.addEventListener('click', () => {
  const name = playerNameInput.value.trim();
  if (!name) return;
  state.player = name;
  playerNameEl.textContent = state.player;
  startOverlay.style.display = 'none';
  beginGame();
});

/* header Start button */
btnStart.addEventListener('click', () => {
  if (!state.player) {
    startOverlay.style.display = 'flex';
    playerNameInput.focus();
  } else if (!state.running) {
    beginGame();
  }
});

/* Abort game (no save) */
function abortGame() {
  if (!state.running) return;

  state.running = false;
  clearInterval(timerInterval);
  timerInterval = null;

  endTitleEl.textContent = "‚õî Game Aborted";
  endTitleEl.className = "end-title aborted";

  endScoreEl.textContent = "Score: " + state.score;
  endRankEl.textContent = "(Not saved to leaderboard)";
  endOverlay.style.display = "flex";

  btnAbort.disabled = true;
}
btnAbort.addEventListener("click", abortGame);

/* ---------- Local scores ---------- */
function saveLocalScore(name, score, timestamp) {
  let list = JSON.parse(localStorage.getItem("localScores") || "[]");
  list.push({ name, score, timestamp });
  list.sort((a, b) => b.score - a.score);
  list = list.slice(0, 500);
  localStorage.setItem("localScores", JSON.stringify(list));
}

function loadLocalScores() {
  return JSON.parse(localStorage.getItem("localScores") || "[]");
}
/* --- Mobile touch drag support --- */
let touchGate = null;

// start drag from gate bar
document.querySelectorAll('.gate-btn').forEach(btn => {
  btn.addEventListener('touchstart', e => {
    e.preventDefault();                 // stop scroll
    const touch = e.touches[0];
    touchGate = { type: btn.dataset.type, id: touch.identifier };
    btn.classList.add('dragging');
  }, { passive:false });
});

// move while finger is anywhere on the screen
document.addEventListener('touchmove', e => {
  if (!touchGate || !state.running || !state.currentBug) return;

  const touch = e.touches[0];
  const lanesRect = lanesEl.getBoundingClientRect();
  const mainAxis = isMobileMode()
    ? (touch.clientX - lanesRect.left)
    : (touch.clientY - lanesRect.top);

  const laneSize = (isMobileMode() ? lanesRect.width : lanesRect.height) / CONFIG.lanes;
  const idx = Math.max(0, Math.min(CONFIG.lanes - 1, Math.floor(mainAxis / laneSize)));

  document.querySelectorAll('.lane')
    .forEach((el, i) => el.classList.toggle('lane-hover', i === idx));

  e.preventDefault(); // keep page from scrolling while dragging
}, { passive:false });

// drop when finger lifts anywhere
document.addEventListener('touchend', e => {
  document.querySelectorAll('.lane').forEach(el => el.classList.remove('lane-hover'));

  if (!touchGate || !state.running || !state.currentBug) {
    touchGate = null;
    document.querySelectorAll('.gate-btn').forEach(x => x.classList.remove('dragging'));
    return;
  }

  const touch = e.changedTouches[0];
  const lanesRect = lanesEl.getBoundingClientRect();
  const mainAxis = isMobileMode()
    ? (touch.clientX - lanesRect.left)
    : (touch.clientY - lanesRect.top);

  const laneSize = (isMobileMode() ? lanesRect.width : lanesRect.height) / CONFIG.lanes;
  const chosen = Math.max(0, Math.min(CONFIG.lanes - 1, Math.floor(mainAxis / laneSize)));

  const coord = isMobileMode() ? touch.clientY : touch.clientX;
  placeGate(touchGate.type, chosen, coord);
  touchGate = null;

  document.querySelectorAll('.gate-btn').forEach(x => x.classList.remove('dragging'));
});

/* Recompute mode label on resize */
window.addEventListener('resize', () => {
  updateHUD();
});
</script>
</body>
</html>


