<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>CI/CD Defense Arcade</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1" />

  <style>
    :root {
      --bg-main: #050814;
      --bg-panel: #0b1020;
      --text-main: #f7f9ff;
      --muted: rgba(230,235,255,0.65);
      --neon-cyan: #6ef6ff;
      --neon-green: #7affb4;
      --neon-orange: #ffb36b;
      --error-red: #ff6b6b;
    }

    * {
      box-sizing: border-box;
    }

    html, body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #18243a 0, #050814 50%, #02030a 100%);
      color: var(--text-main);
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      overscroll-behavior: none;
    }

    body {
      user-select: none;
    }

    .wrap {
      max-width: 1200px;
      margin: 16px auto;
      padding: 16px 18px 22px;
      background: linear-gradient(135deg, rgba(255,255,255,0.03), rgba(0,0,0,0.7));
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,0.08);
      box-shadow:
        0 18px 40px rgba(0,0,0,0.6),
        0 0 0 1px rgba(255,255,255,0.02);
      display: flex;
      flex-direction: column;
      gap: 10px;
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 12px;
    }

    header h1 {
      margin: 0;
      font-size: 22px;
      letter-spacing: 0.1em;
      text-transform: uppercase;
      color: var(--neon-cyan);
    }

    .controls {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      align-items: center;
    }

    .pill {
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255,255,255,0.05);
      font-size: 12px;
    }

    .pill span {
      font-weight: 600;
    }

    button {
      font-family: inherit;
      cursor: pointer;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      padding: 6px 12px;
      font-size: 12px;
      background: rgba(255,255,255,0.02);
      color: var(--text-main);
      transition: background 0.15s ease, transform 0.07s ease, box-shadow 0.15s ease;
    }

    button:hover:not(:disabled) {
      background: rgba(255,255,255,0.08);
      transform: translateY(-1px);
      box-shadow: 0 0 0 1px rgba(255,255,255,0.1);
    }

    button:active:not(:disabled) {
      transform: translateY(1px) scale(0.98);
      box-shadow: none;
    }

    button:disabled {
      opacity: 0.5;
      cursor: default;
    }

    .btn-primary {
      background: linear-gradient(135deg, var(--neon-cyan), var(--neon-green));
      border-color: rgba(0,0,0,0.4);
      color: #051018;
      font-weight: 700;
    }

    .main {
      display: flex;
      flex-direction: column;
      gap: 8px;
      flex: 1;
    }

    .hud {
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
    }

    .hud-chip {
      padding: 4px 8px;
      border-radius: 999px;
      background: rgba(0,0,0,0.7);
      font-size: 11px;
    }

    .hud-label {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 10px;
      color: var(--muted);
      margin-right: 4px;
    }

    .hud-value {
      font-weight: 600;
    }

    .game-area {
      position: relative;
      border-radius: 14px;
      background: radial-gradient(circle at top, #19243d 0, #050814 55%, #01020a 100%);
      border: 1px solid rgba(255,255,255,0.1);
      min-height: 340px;
      overflow: hidden;
      flex: 1;
      padding: 16px;
    }

    .wave-banner {
      position: absolute;
      top: 8px;
      left: 50%;
      transform: translateX(-50%);
      padding: 3px 10px;
      border-radius: 999px;
      background: rgba(5,10,25,0.9);
      border: 1px solid var(--neon-cyan);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      color: var(--neon-cyan);
      z-index: 5;
    }

    .lanes {
      position: relative;
      margin: 38px 160px 32px 12px;
      height: 260px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 2;
    }

    .lane {
      position: relative;
      flex: 1;
      border-radius: 10px;
      background: linear-gradient(90deg, rgba(255,255,255,0.03), rgba(0,0,0,0.7));
      border: 1px solid rgba(255,255,255,0.1);
    }

    .lane-label {
      position: absolute;
      left: 8px;
      top: 4px;
      font-size: 10px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: rgba(240,245,255,0.6);
    }

    .line-left {
      position: absolute;
      left: 10px;
      top: 0;
      bottom: 0;
      width: 3px;
      background: linear-gradient(to bottom, var(--neon-cyan), transparent 40%, transparent 60%, var(--neon-cyan));
      opacity: 0.5;
    }

    .lane-hover {
      box-shadow: 0 0 0 1px var(--neon-cyan), 0 0 16px rgba(110,246,255,0.6);
      border-color: var(--neon-cyan);
    }

    .prod-column {
      position: absolute;
      top: 56px;
      right: 16px;
      width: 120px;
      border-radius: 14px;
      padding: 8px 8px 10px;
      background: radial-gradient(circle at top, #1f2a46, #050814);
      border: 1px solid rgba(255,255,255,0.25);
      text-align: center;
      z-index: 4;
    }

    .prod-icon {
      font-size: 22px;
    }

    .prod-label {
      margin-top: 2px;
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.14em;
      color: var(--muted);
    }

    .health {
      margin-top: 6px;
      height: 10px;
      border-radius: 999px;
      background: rgba(0,0,0,0.7);
      border: 1px solid rgba(255,255,255,0.25);
      overflow: hidden;
    }

    .health-inner {
      height: 100%;
      width: 100%;
      background: linear-gradient(90deg, var(--neon-green), var(--neon-cyan));
      box-shadow: 0 0 14px rgba(122,255,180,0.7);
      transition: width 0.2s ease-out, background 0.2s ease-out;
    }

    .prod-column.hit {
      animation: prod-hit 0.25s ease-out;
    }

    @keyframes prod-hit {
      0% { transform: translateY(0); }
      20% { transform: translateY(-2px); }
      60% { transform: translateY(1px); }
      100% { transform: translateY(0); }
    }

    .bug {
      position: absolute;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 3px 9px;
      border-radius: 999px;
      background: rgba(15,25,55,0.95);
      border: 1px solid rgba(110,246,255,0.7);
      font-size: 11px;
      white-space: nowrap;
      box-shadow: 0 0 12px rgba(110,246,255,0.6), 0 0 0 1px rgba(0,0,0,0.8);
      z-index: 40;
    }

    .bug .icon {
      font-size: 13px;
    }

    .lane-gate {
      position: absolute;
      width: 110px;
      height: 50px;
      display: flex;
      align-items: center;
      justify-content: center;
      pointer-events: none;
      z-index: 60;
    }

    .lane-gate-line {
      position: absolute;
      height: 2px;
      width: 90%;
      background: rgba(255,255,255,0.14);
      box-shadow: 0 0 10px rgba(255,255,255,0.4);
    }

    .lane-gate-label {
      position: relative;
      padding: 2px 10px;
      border-radius: 999px;
      font-size: 9px;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.12em;
      border: 1px solid rgba(255,255,255,0.3);
    }

    .lane-gate-unit .lane-gate-line {
      background: rgba(110,246,255,0.8);
    }
    .lane-gate-unit .lane-gate-label {
      background: rgba(110,246,255,0.15);
      color: var(--neon-cyan);
    }

    .lane-gate-contract .lane-gate-line {
      background: rgba(122,255,180,0.8);
    }
    .lane-gate-contract .lane-gate-label {
      background: rgba(122,255,180,0.16);
      color: var(--neon-green);
    }

    .lane-gate-integration .lane-gate-line {
      background: rgba(255,179,107,0.8);
    }
    .lane-gate-integration .lane-gate-label {
      background: rgba(255,179,107,0.15);
      color: var(--neon-orange);
    }

    .gate-bar {
      margin-top: 10px;
      display: flex;
      gap: 8px;
    }

    .gate-btn {
      flex: 1;
      padding: 8px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.2);
      font-size: 11px;
      font-weight: 700;
      text-align: center;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      background: rgba(0,0,0,0.75);
      touch-action: none;
    }

    .gate-btn.blue { border-color: var(--neon-cyan); }
    .gate-btn.green { border-color: var(--neon-green); }
    .gate-btn.orange { border-color: var(--neon-orange); }

    .gate-btn.dragging {
      opacity: 0.5;
    }

    .end-overlay {
      position: absolute;
      inset: 0;
      background: rgba(0,0,0,0.85);
      display: flex;
      align-items: center;
      justify-content: center;
      z-index: 100;
    }

    .end-card {
      min-width: 260px;
      max-width: 340px;
      padding: 18px 16px 14px;
      border-radius: 14px;
      background: radial-gradient(circle at top, #202947, #050814);
      border: 1px solid rgba(255,255,255,0.24);
      text-align: center;
    }

    .end-title {
      font-size: 18px;
      margin-bottom: 4px;
    }

    .end-score {
      font-size: 14px;
      margin-bottom: 4px;
    }

    .end-rank {
      font-size: 13px;
      color: var(--neon-orange);
      min-height: 18px;
    }

    .end-actions {
      margin-top: 10px;
      display: flex;
      flex-wrap: wrap;
      gap: 6px;
      justify-content: center;
    }

    .name-input {
      margin-top: 8px;
      width: 100%;
      padding: 7px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,0.18);
      background: rgba(0,0,0,0.7);
      color: var(--text-main);
      font-size: 13px;
      text-align: center;
    }

    .footer-tip {
      font-size: 11px;
      color: var(--muted);
    }

    @keyframes pop {
      0%   { transform: scale(0.82); }
      50%  { transform: scale(1.04); }
      100% { transform: scale(1.0); }
    }

    .floating-text {
      position: absolute;
      font-size: 14px;
      font-weight: 700;
      pointer-events: none;
      text-shadow: 0 0 8px rgba(0,0,0,0.7);
      z-index: 80;
    }

    /* =============== MOBILE FULLSCREEN MODE ================= */
    @media (max-width: 600px) {
      html, body {
        height: 100%;
        overflow: hidden !important;
        touch-action: none;
      }

      .wrap {
        margin: 0;
        padding: 8px 8px 72px;
        border-radius: 0;
        border: none;
        height: 100vh;
        max-width: 100%;
      }

      header {
        display: none;
      }

      .main {
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      .game-area {
        flex: 1;
        padding: 8px;
        border-radius: 10px;
        min-height: 0;
      }

      .lanes {
        margin: 32px 4px 6px 4px;
        height: auto;
        flex: 1;
        display: flex;
        flex-direction: row;
        gap: 4px;
      }

      .lane {
        flex: 1;
        height: 100%;
        min-width: 0;
      }

      .line-left {
        display: none;
      }

      .prod-column {
        position: relative;
        top: 0;
        right: 0;
        margin: 0 auto 4px auto;
      }

      .gate-bar {
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        margin: 0;
        border-radius: 0;
        padding: 8px 8px 10px;
        background: rgba(0,0,0,0.92);
        border-top: 1px solid rgba(255,255,255,0.2);
        z-index: 9999;
      }

      .gate-btn {
        font-size: 11px;
        padding: 8px 6px;
      }

      .footer-tip {
        display: none;
      }

      .end-overlay {
        position: fixed;
      }
    }
  </style>
</head>
<body>
<div class="wrap">
  <header>
    <h1>CI/CD Defense Arcade</h1>
    <div class="controls">
      <div class="pill">Player: <span id="playerName">‚Äî</span></div>
      <div class="pill">Score: <span id="score">0</span></div>
      <div class="pill">Combo: <span id="combo">0</span></div>
      <button id="btnStart" class="btn-primary">‚ñ∂ Start</button>
      <button id="btnAbort" disabled>Abort</button>
    </div>
  </header>

  <div class="main">
    <div class="hud">
      <div class="hud-chip">
        <span class="hud-label">Mode</span>
        <span class="hud-value" id="modeLbl">Classic</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Upcoming</span>
        <span class="hud-value" id="upcoming">‚Äî</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Remaining</span>
        <span class="hud-value" id="remaining">‚Äî</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Speed</span>
        <span class="hud-value" id="speedLbl">1.00x</span>
      </div>
      <div class="hud-chip">
        <span class="hud-label">Time</span>
        <span class="hud-value" id="timer">90</span><span class="hud-unit">s</span>
      </div>
    </div>

    <div class="game-area" id="gameArea">
      <div class="wave-banner" id="banner">Ready</div>
      <div class="lanes" id="lanes"></div>

      <div class="prod-column healthy" id="prodCol">
        <div class="prod-icon">‚öôÔ∏è</div>
        <div class="prod-label">PROD</div>
        <div class="health">
          <div id="healthInner" class="health-inner"></div>
        </div>
      </div>

      <!-- End overlay -->
      <div id="endOverlay" class="end-overlay" style="display:none">
        <div class="end-card">
          <div id="endTitle" class="end-title">Time Up!</div>
          <div id="endScore" class="end-score">Score: 0</div>
          <div id="endRank" class="end-rank"></div>
          <div class="end-actions">
            <button id="endBtnPlay">Play Again</button>
            <button id="endBtnNew">New Game</button>
          </div>
        </div>
      </div>

      <!-- Start overlay -->
      <div id="startOverlay" class="end-overlay" style="display:flex">
        <div class="end-card">
          <div class="end-title">CI/CD Defense Arcade</div>
          <div class="end-score">Defend PROD from sneaky CI/CD bugs!</div>
          <input id="playerNameInput" class="name-input" placeholder="Type your hero name here" />
          <div class="end-rank">Drag UNIT / CONTRACT / INTEGRATION gates onto builds to stop bugs early.</div>
          <div class="end-actions">
            <button id="startOverlayBtn" disabled>Start Game ‚ñ∂</button>
          </div>
        </div>
      </div>
    </div>

    <div class="gate-bar" id="gateBar">
      <div class="gate-btn blue" data-type="unit">UNIT TEST</div>
      <div class="gate-btn green" data-type="contract">CONTRACT TEST</div>
      <div class="gate-btn orange" data-type="integration">INTEGRATION</div>
    </div>
  </div>

  <footer class="footer-tip">
    üí° Tip: Drag a gate from the bottom bar and drop it onto a build lane. Earlier, correct gates give more points. Bugs hitting PROD damage stability!
  </footer>
</div>

<script>
  /* ================= CONFIG & STATE ================== */
  const GAME_DURATION = 90;
  const CONFIG = {
    lanesDesktop: 5,
    lanesMobile: 4,
    totalBugs: 60,
    bugTravelSeconds: 15,
    prodMax: 100,
    wrongPauseMs: 500,
    scoring: {
      correctMax: 250,
      correctMin: 50,
      wrongGate: -100,
      hitProd: -500,
      comboBonus: 1000,
      comboSize: 3
    }
  };

  function isMobileMode() {
    return window.innerWidth <= 600;
  }
  function getLaneCount() {
    return isMobileMode() ? CONFIG.lanesMobile : CONFIG.lanesDesktop;
  }

  let state = {
    player: null,
    score: 0,
    combo: 0,
    health: CONFIG.prodMax,
    currentBug: null,
    remaining: CONFIG.totalBugs,
    spawnedCount: 0,
    running: false
  };

  let timerInterval = null;

  /* ============== DOM REFERENCES ================= */
  const lanesEl        = document.getElementById('lanes');
  const gameArea       = document.getElementById('gameArea');
  const banner         = document.getElementById('banner');
  const healthInner    = document.getElementById('healthInner');
  const scoreEl        = document.getElementById('score');
  const comboEl        = document.getElementById('combo');
  const remainingEl    = document.getElementById('remaining');
  const upcomingEl     = document.getElementById('upcoming');
  const speedLbl       = document.getElementById('speedLbl');
  const modeLbl        = document.getElementById('modeLbl');
  const prodCol        = document.getElementById('prodCol');

  const btnStart       = document.getElementById('btnStart');
  const btnAbort       = document.getElementById('btnAbort');
  const endOverlay     = document.getElementById('endOverlay');
  const endTitleEl     = document.getElementById('endTitle');
  const endScoreEl     = document.getElementById('endScore');
  const endRankEl      = document.getElementById('endRank');
  const endBtnPlay     = document.getElementById('endBtnPlay');
  const endBtnNew      = document.getElementById('endBtnNew');
  const startOverlay   = document.getElementById('startOverlay');
  const startOverlayBtn= document.getElementById('startOverlayBtn');
  const playerNameInput= document.getElementById('playerNameInput');
  const playerNameEl   = document.getElementById('playerName');
  const gateButtons    = Array.from(document.querySelectorAll('.gate-btn'));

  /* ============== BUG POOL =================== */
  const BUG_POOL = (function(){
    const seeds = [
      'Off-by-one error','Wrong variable type','Null pointer in util','GST calc wrong','Rounding mismatch',
      'Missing validation','Incorrect loop bound','Uninitialized var','Edge-case divide by zero','Wrong default value',
      'Wrong comparator','Floating precision bug','Wrong sign on calculation','Index out of range','Incorrect accumulator',
      'Wrong math formula','Missing unit test','Order of operations bug','Bad regex logic','Wrong constant used',
      'Locale number parse bug','Time-zone handling bug','Incorrect flag check','State mutation bug','Callback misuse',
      'API contract mismatch','Missing response field','Wrong HTTP status','Schema version mismatch','Field type mismatch',
      'Unexpected null in response','Header missing','Wrong content-type','Response shape changed','Deprecated field used',
      'Payload key typo','Missing required param','Extra field in response','Versioning mismatch','Incorrect enum value',
      'Invalid JSON format','Missing validation in schema','Query param name typo','Incorrect date format','Wrong pagination format',
      'DB query fails intermittently','Config missing in CI','Container env mismatch','Service timeout','Race condition across services',
      'Circuit breaker not set','Retry logic missing','Downstream API latency','Wrong endpoint routing','Auth token refresh failure',
      'Network partition issue','Load balancer misroute','Session stickiness lost','Wrong service discovery','SSL cert mismatch'
    ];
    return seeds.map((t,idx)=>({
      id:'b'+idx,
      label:t,
      right: idx<25? 'unit' : idx<50? 'contract' : 'integration',
      icon: 'üêû'
    }));
  })();

  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j=Math.floor(Math.random()*(i+1));
      [a[i],a[j]]=[a[j],a[i]];
    }
    return a;
  }
  let bugQueue = shuffle([...BUG_POOL]);
  function getNextBugDef(){
    if(bugQueue.length===0) bugQueue = shuffle([...BUG_POOL]);
    return bugQueue.shift();
  }

  /* ============== UTIL: AUDIO BEEP =================== */
  function beep(freq=440,dur=0.06){
    try{
      const Ctx = window.AudioContext || window.webkitAudioContext;
      const ctx = new Ctx();
      const o=ctx.createOscillator(), g=ctx.createGain();
      o.connect(g); g.connect(ctx.destination);
      o.frequency.value=freq;
      o.start();
      g.gain.setValueAtTime(0.0001,ctx.currentTime);
      g.gain.exponentialRampToValueAtTime(0.12, ctx.currentTime+0.01);
      g.gain.exponentialRampToValueAtTime(0.0001, ctx.currentTime+dur);
      o.stop(ctx.currentTime+dur+0.02);
    }catch(e){}
  }

  /* ============== UI =================== */
  function updateHUD(){
    scoreEl.textContent = state.score;
    comboEl.textContent = state.combo;
    remainingEl.textContent = state.remaining;
    const speedFactor = 1 + (state.spawnedCount*0.12);
    speedLbl.textContent = speedFactor.toFixed(2)+'x';
    upcomingEl.textContent = state.currentBug ? state.currentBug.def.label : '‚Äî';
    modeLbl.textContent = isMobileMode()
      ? `Mobile (vertical, ${CONFIG.lanesMobile} builds)`
      : `Desktop (horizontal, ${CONFIG.lanesDesktop} builds)`;
  }

  function updateHealth(){
    const pct = Math.max(0, Math.floor((state.health/CONFIG.prodMax)*100));
    healthInner.style.width = pct + '%';
    if(pct < 30)
      healthInner.style.background = 'linear-gradient(90deg,#ff6b6b,#ff8a3d)';
    else
      healthInner.style.background = 'linear-gradient(90deg,var(--neon-green),var(--neon-cyan))';
  }

  function flashBanner(text, ms=900){
    const old = banner.textContent;
    banner.textContent = text;
    banner.style.animation = 'pop 0.4s ease-out';
    setTimeout(()=>{
      banner.textContent = old;
      banner.style.animation = '';
    }, ms);
  }

  function showFloatingText(text, x, y, color){
    const node = document.createElement('div');
    node.className = 'floating-text';
    node.textContent = text;
    node.style.left = x + 'px';
    node.style.top  = y + 'px';
    node.style.color = color || '#fff';
    gameArea.appendChild(node);
    node.animate(
      [{transform:'translateY(0)', opacity:1},{transform:'translateY(-32px)', opacity:0}],
      {duration:750, easing:'ease-out'}
    );
    setTimeout(()=>{ try{node.remove();}catch(e){} }, 750);
  }

  /* ============== LANES BUILD =================== */
  function buildLanes(){
    lanesEl.innerHTML = '';
    const count = getLaneCount();
    for(let i=0;i<count;i++){
      const lane = document.createElement('div');
      lane.className = 'lane';
      lane.dataset.index = i;
      const label = document.createElement('div');
      label.className = 'lane-label';
      label.textContent = `Build ${i+1}`;
      lane.appendChild(label);
      const line = document.createElement('div');
      line.className = 'line-left';
      lane.appendChild(line);
      lanesEl.appendChild(lane);
    }
    updateHUD();
  }
  buildLanes();

  window.addEventListener('resize', ()=>{
    const running = state.running;
    buildLanes();
    if(running){
      resetSession();
    }
  });

  /* ============== GATE PLACEMENT =================== */
  function placeGate(type, laneIndex, clientX, clientY){
    if(!state.currentBug) return;

    const areaRect = gameArea.getBoundingClientRect();
    const laneEl = lanesEl.children[laneIndex];
    const laneRect = laneEl.getBoundingClientRect();

    const node = document.createElement('div');
    node.className = 'lane-gate lane-gate-' + type;
    const line = document.createElement('div');
    line.className = 'lane-gate-line';
    const label = document.createElement('div');
    label.className = 'lane-gate-label';
    label.textContent = type.toUpperCase();
    node.appendChild(line);
    node.appendChild(label);
    gameArea.appendChild(node);

    let centerX, centerY;

    if(isMobileMode()){
      centerX = (laneRect.left - areaRect.left) + laneRect.width/2;
      centerY = clientY ? (clientY - areaRect.top) : (laneRect.top - areaRect.top + laneRect.height/2);
      const topLimit = (laneRect.top - areaRect.top) + 30;
      const bottomLimit = (laneRect.bottom - areaRect.top) - 30;
      centerY = Math.max(topLimit, Math.min(centerY, bottomLimit));
    } else {
      centerY = laneRect.top - areaRect.top + laneRect.height/2;
      centerX = clientX - areaRect.left;
      const leftLimit = 50;
      const rightLimit = areaRect.width - 50;
      centerX = Math.max(leftLimit, Math.min(centerX, rightLimit));
    }

    node.style.left = (centerX - node.offsetWidth/2) + 'px';
    node.style.top  = (centerY - node.offsetHeight/2) + 'px';

    node.animate(
      [{transform:'scale(.86)'},{transform:'scale(1.02)'},{transform:'scale(1)'}],
      {duration:220}
    );
    beep(520,0.06);

    if(!window._placedGates) window._placedGates = [];
    window._placedGates.push({
      el: node,
      type,
      lane: laneIndex,
      centerX,
      centerY,
      consumed: false
    });
  }

  /* ============== BUG SPAWN / MOVEMENT =================== */
  function spawnNextBug(){
    if(!state.running) return;
    if(state.currentBug) return;
    if(state.remaining <= 0) return;

    const def = getNextBugDef();
    const count = getLaneCount();
    const row = Math.floor(Math.random()*count);
    const laneEl = lanesEl.children[row];
    const areaRect = gameArea.getBoundingClientRect();
    const laneRect = laneEl.getBoundingClientRect();
    const prodRect = prodCol.getBoundingClientRect();

    const bugEl = document.createElement('div');
    bugEl.className = 'bug';
    bugEl.innerHTML = `<span class="icon">${def.icon}</span><span>${def.label}</span>`;
    gameArea.appendChild(bugEl);

    let bug = {
      def,
      row,
      el: bugEl,
      x: 0,
      y: 0,
      vx: 0,
      vy: 0,
      pausedUntil: 0,
      active: true,
      thresholdX: null,
      thresholdY: null
    };

    if(isMobileMode()){
      const startX = (laneRect.left - areaRect.left) + laneRect.width/2 - bugEl.offsetWidth/2;
      const startY = (laneRect.top - areaRect.top) + 10;
      bug.x = startX;
      bug.y = startY;
      bugEl.style.left = startX + 'px';
      bugEl.style.top  = startY + 'px';

      const thresholdY = (laneRect.bottom - areaRect.top) - bugEl.offsetHeight - 6;
      bug.thresholdY = thresholdY;
      bug.vy = (thresholdY - startY) / CONFIG.bugTravelSeconds;
    } else {
      const y = laneRect.top - areaRect.top + laneRect.height/2 - bugEl.offsetHeight/2;
      const startX = (laneRect.left - areaRect.left) + 10;
      bug.x = startX;
      bug.y = y;
      bugEl.style.left = startX + 'px';
      bugEl.style.top  = y + 'px';

      const prodThreshold = prodRect.left - areaRect.left - bugEl.offsetWidth;
      const safeThreshold = Math.max(prodThreshold, startX + 120);
      bug.thresholdX = safeThreshold;
      const distance = safeThreshold - startX;
      bug.vx = distance / CONFIG.bugTravelSeconds;
    }

    state.currentBug = bug;
    state.spawnedCount++;
    state.remaining--;

    upcomingEl.textContent = def.label;
    updateHUD();

    const gateName =
      def.right === 'unit'        ? 'UNIT TEST' :
      def.right === 'contract'    ? 'CONTRACT TEST' :
      def.right === 'integration' ? 'INTEGRATION' :
      def.right.toUpperCase();
    banner.textContent = `Incoming: ${def.label} (${gateName})`;
  }

  function computeDynamicScore(gate, bug){
    const maxScore = CONFIG.scoring.correctMax;
    const minScore = CONFIG.scoring.correctMin;
    if(isMobileMode()){
      const tRaw = gate.centerY / Math.max(bug.thresholdY || 1, 1);
      const t = Math.min(Math.max(tRaw, 0), 1);
      return Math.round(maxScore - t * (maxScore - minScore));
    } else {
      const tRaw = gate.centerX / Math.max(bug.thresholdX || 1, 1);
      const t = Math.min(Math.max(tRaw, 0), 1);
      return Math.round(maxScore - t * (maxScore - minScore));
    }
  }

  function handleGateHit(bug, gate){
    gate.consumed = true;
    const gx = gate.centerX;
    const gy = gate.centerY - 18;

    if(gate.type === bug.def.right){
      const sc = computeDynamicScore(gate, bug);
      state.score += sc;
      state.combo++;
      beep(800,0.08);
      showFloatingText(`+${sc}`, gx, gy, '#7affb4');

      if(state.combo>0 && state.combo % CONFIG.scoring.comboSize === 0){
        state.score += CONFIG.scoring.comboBonus;
        showFloatingText(`+${CONFIG.scoring.comboBonus}`, gx+6, gy-20, '#ffd36b');
        flashBanner(`Combo! +${CONFIG.scoring.comboBonus}`);
      }

      bug.active = false;
      try{ bug.el.remove(); }catch(e){}
      try{ gate.el.remove(); }catch(e){}
      window._placedGates = (window._placedGates || []).filter(g=>g!==gate);
      state.currentBug = null;
      updateHUD();
      spawnNextBug();
    } else {
      state.score += CONFIG.scoring.wrongGate;
      state.combo = 0;
      beep(180,0.08);
      showFloatingText(`${CONFIG.scoring.wrongGate}`, gx, gy, '#ff6b6b');

      bug.pausedUntil = performance.now() + CONFIG.wrongPauseMs;
      gate.el.style.opacity = '0.25';
      setTimeout(()=>{
        try{ gate.el.remove(); }catch(e){}
        window._placedGates = (window._placedGates || []).filter(g=>g!==gate);
      }, 400);
      updateHUD();
    }
  }

  function hitProd(bug){
    state.score += CONFIG.scoring.hitProd;
    state.combo = 0;
    state.health -= 20;
    if(state.health < 0) state.health = 0;

    updateHealth();
    beep(120,0.12);

    const areaRect = gameArea.getBoundingClientRect();
    const prodRect = prodCol.getBoundingClientRect();
    const sx = (prodRect.left - areaRect.left) + 20;
    const sy = (prodRect.top - areaRect.top) + 18;
    showFloatingText(`${CONFIG.scoring.hitProd}`, sx+10, sy-10, '#ff6b6b');

    prodCol.classList.add('hit');
    setTimeout(()=>prodCol.classList.remove('hit'), 300);

    bug.active = false;
    try{ bug.el.remove(); }catch(e){}
    state.currentBug = null;
    updateHUD();

    if(state.health <= 0){
      endGame('Production meltdown!');
    } else if(state.remaining <= 0){
      endGame('All bugs processed.');
    } else {
      spawnNextBug();
    }
  }

  let lastTime = null;
  function gameLoop(ts){
    if(!lastTime) lastTime = ts;
    const dt = ts - lastTime;
    lastTime = ts;

    if(state.running && state.currentBug && state.currentBug.active){
      const bug = state.currentBug;
      const now = performance.now();

      if(now >= bug.pausedUntil){
        const dtSec = dt / 1000;

        if(isMobileMode()){
          bug.y += bug.vy * dtSec;
          bug.el.style.top = bug.y + 'px';

          const gates = (window._placedGates || []);
          for(const gate of gates){
            if(gate.consumed) continue;
            if(gate.lane !== bug.row) continue;
            const bugBottom = bug.y + bug.el.offsetHeight;
            const gateTop = gate.centerY - 14;
            const gateBottom = gate.centerY + 14;
            if(bugBottom >= gateTop && bug.y <= gateBottom){
              handleGateHit(bug, gate);
              break;
            }
          }

          if(bug.active && bug.thresholdY !== null){
            if(bug.y >= bug.thresholdY){
              hitProd(bug);
            }
          }
        } else {
          bug.x += bug.vx * dtSec;
          bug.el.style.left = bug.x + 'px';

          const gates = (window._placedGates || []);
          for(const gate of gates){
            if(gate.consumed) continue;
            if(gate.lane !== bug.row) continue;
            const bugRight = bug.x + bug.el.offsetWidth;
            const gateLeft = gate.centerX - 16;
            const gateRight = gate.centerX + 16;
            if(bugRight >= gateLeft && bug.x <= gateRight){
              handleGateHit(bug, gate);
              break;
            }
          }

          if(bug.active && bug.thresholdX !== null){
            if(bug.x >= bug.thresholdX){
              hitProd(bug);
            }
          }
        }
      }
    }

    requestAnimationFrame(gameLoop);
  }
  requestAnimationFrame(gameLoop);

  /* ============== GAME CONTROL =================== */
  function resetSession(){
    state.running = false;
    clearInterval(timerInterval);
    timerInterval = null;

    endOverlay.style.display = 'none';

    if(state.currentBug && state.currentBug.el){
      try{ state.currentBug.el.remove(); }catch(e){}
    }
    state.currentBug = null;

    (window._placedGates || []).forEach(g=>{
      try{ g.el.remove(); }catch(e){}
    });
    window._placedGates = [];

    state.score = 0;
    state.combo = 0;
    state.health = CONFIG.prodMax;
    state.remaining = CONFIG.totalBugs;
    state.spawnedCount = 0;

    document.getElementById('timer').textContent = GAME_DURATION;
    banner.textContent = 'Ready';
    updateHealth();
    updateHUD();
  }

  function showEndOverlay(reason){
    let title = 'Game Over';
    if(reason && reason.toLowerCase().includes('time')){
      title = '‚è∞ Time Up!';
    } else if(reason && reason.toLowerCase().includes('meltdown')){
      title = 'üî• Production Meltdown!';
    } else if(reason){
      title = reason;
    }
    endTitleEl.textContent = title;
    endScoreEl.textContent = `Score: ${state.score}`;
    endRankEl.textContent = '';
    endOverlay.style.display = 'flex';
  }

  function endGame(reason){
    state.running = false;
    clearInterval(timerInterval);
    timerInterval = null;
    banner.textContent = reason || 'Game over';
    showEndOverlay(reason);
  }

  function beginGame(){
    resetSession();
    state.running = true;
    lastTime = null;
    btnAbort.disabled = false;

    let timeLeft = GAME_DURATION;
    document.getElementById('timer').textContent = timeLeft;
    timerInterval = setInterval(()=>{
      timeLeft--;
      if(timeLeft < 0) timeLeft = 0;
      document.getElementById('timer').textContent = timeLeft;
      if(timeLeft <= 0){
        clearInterval(timerInterval);
        timerInterval = null;
        if(state.running) endGame('Time up!');
      }
    }, 1000);

    spawnNextBug();
  }

  /* ============== NAME INPUT & BUTTONS =================== */
  playerNameInput.addEventListener('input', ()=>{
    const val = playerNameInput.value.trim();
    startOverlayBtn.disabled = !val;
  });

  startOverlayBtn.addEventListener('click', ()=>{
    const name = playerNameInput.value.trim();
    if(!name) return;
    state.player = name;
    playerNameEl.textContent = name;
    startOverlay.style.display = 'none';
    beginGame();
  });

  btnStart.addEventListener('click', ()=>{
    if(!state.player){
      startOverlay.style.display = 'flex';
      playerNameInput.focus();
    } else if(!state.running){
      beginGame();
    }
  });

  endBtnPlay.addEventListener('click', ()=>{
    if(state.player){
      beginGame();
    } else {
      startOverlay.style.display = 'flex';
    }
  });

  endBtnNew.addEventListener('click', ()=>{
    endOverlay.style.display = 'none';
    resetSession();
    state.player = null;
    playerNameEl.textContent = '‚Äî';
    playerNameInput.value = '';
    startOverlayBtn.disabled = true;
    startOverlay.style.display = 'flex';
    playerNameInput.focus();
  });

  btnAbort.addEventListener('click', ()=>{
    if(!state.running) return;
    state.running = false;
    clearInterval(timerInterval);
    timerInterval = null;
    endTitleEl.textContent = '‚õî Game Aborted';
    endScoreEl.textContent = `Score: ${state.score}`;
    endRankEl.textContent = '(Not saved)';
    endOverlay.style.display = 'flex';
    btnAbort.disabled = true;
  });

  /* ============== DRAG & DROP (MOUSE + TOUCH) =================== */
  let dragGateType = null;
  let dragGhost = null;

  function startDragGate(type, clientX, clientY){
    dragGateType = type;

    dragGhost = document.createElement('div');
    dragGhost.className = 'gate-btn dragging';
    dragGhost.style.position = 'fixed';
    dragGhost.style.left = (clientX - 60) + 'px';
    dragGhost.style.top  = (clientY - 20) + 'px';
    dragGhost.style.pointerEvents = 'none';
    dragGhost.style.opacity = '0.7';
    dragGhost.style.zIndex = '99999';
    dragGhost.textContent = type.toUpperCase();
    document.body.appendChild(dragGhost);
  }

  function moveDragGate(clientX, clientY){
    if(!dragGhost) return;
    dragGhost.style.left = (clientX - 60) + 'px';
    dragGhost.style.top  = (clientY - 20) + 'px';
  }

  function endDragGate(clientX, clientY){
    if(!dragGateType || !dragGhost){
      dragGateType = null;
      return;
    }
    dragGhost.remove();
    dragGhost = null;

    const lanesRect = lanesEl.getBoundingClientRect();
    const count = getLaneCount();
    let laneIndex = null;

    if(isMobileMode()){
      const x = clientX;
      const laneWidth = lanesRect.width / count;
      const idx = Math.floor((x - lanesRect.left) / laneWidth);
      if(idx >= 0 && idx < count) laneIndex = idx;
    } else {
      const y = clientY;
      const laneHeight = lanesRect.height / count;
      const idx = Math.floor((y - lanesRect.top) / laneHeight);
      if(idx >= 0 && idx < count) laneIndex = idx;
    }

    if(laneIndex !== null && state.running && state.currentBug){
      placeGate(dragGateType, laneIndex, clientX, clientY);
    }
    dragGateType = null;
  }

  // Mouse
  gateButtons.forEach(btn=>{
    btn.addEventListener('mousedown', e=>{
      if(isMobileMode()) return; // mouse on mobile not needed
      e.preventDefault();
      startDragGate(btn.dataset.type, e.clientX, e.clientY);
      window.addEventListener('mousemove', mouseMoveDrag);
      window.addEventListener('mouseup', mouseUpDrag, { once:true });
    });
  });

  function mouseMoveDrag(e){
    moveDragGate(e.clientX, e.clientY);
  }
  function mouseUpDrag(e){
    window.removeEventListener('mousemove', mouseMoveDrag);
    endDragGate(e.clientX, e.clientY);
  }

  // Touch
  gateButtons.forEach(btn=>{
    btn.addEventListener('touchstart', e=>{
      e.preventDefault();
      const t = e.touches[0];
      startDragGate(btn.dataset.type, t.clientX, t.clientY);
    });
    btn.addEventListener('touchmove', e=>{
      e.preventDefault();
      const t = e.touches[0];
      moveDragGate(t.clientX, t.clientY);
    });
    btn.addEventListener('touchend', e=>{
      e.preventDefault();
      const t = e.changedTouches[0];
      endDragGate(t.clientX, t.clientY);
    });
  });
</script>
</body>
</html>
